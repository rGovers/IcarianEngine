#version 450

layout(location = 0) in vec2 vUV;

layout(binding = 0) uniform sampler2D colorSampler;
layout(binding = 1) uniform sampler2D normalSampler;
layout(binding = 2) uniform sampler2D emissionSampler;
layout(binding = 3) uniform sampler2D depthSampler;

#!structure(CameraBuffer, 4, 1, camBuffer)

// Credit: https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl
float rand(vec2 co)
{
    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);
}

layout(location = 0) out vec4 fragColor;

const int kernelSize = 16;
const float ssaoRadius = 0.25;

// Tone map settings
const float exposure = 1.5;

// Blur settings
const int directions = 8;
const float emissionRadius = 0.005;
const int quality = 3;
const float pi2 = 6.2831850718;

// TODO: Rewite shader down the line
void main()
{
    vec4 normal = texture(normalSampler, vUV);   

    float d = texture(depthSampler, vUV).x;
    vec4 cP = vec4(vUV * 2.0 + -1.0, d, 1.0);
    vec4 vP = camBuffer.InvProj * cP;
    vP /= vP.w;
    
    // SSAO
    vec3 v = normalize(vec3(rand(vUV) * 2 + -1, rand(vUV + vec2(0.5, 0.5)) * 2 + -1, 0.0));

    vec3 t = normalize(v - normal.xyz * dot(v, normal.xyz));
    vec3 bT = cross(normal.xyz, t);
    mat3 TBN = mat3(t, bT, normal.xyz);

    float occlusion = 0.0;

    for (int i = 0; i < kernelSize; i++)
    {
        float s = i / float(kernelSize);
        vec3 k = normalize(vec3(rand(vUV + vec2(0.1, 0.2) + s) * 2 + -1, rand(vUV + vec2(0.3, 0.4) + s) * 2 + -1, rand(vUV + vec2(0.6, 0.7) + s)));

        vec3 kS = k * s;

        vec3 sP = vP.xyz - (TBN * kS) * ssaoRadius;
        vec4 oF = camBuffer.Proj * vec4(sP, 1.0);
        oF /= oF.w;
        vec3 t = oF.xyz * 0.5 + 0.5;

        float sD = texture(depthSampler, t.xy).x;
        vec3 dP = vec3(t.xy * 2.0 + -1.0, sD);
        vec4 sV = camBuffer.InvProj * vec4(dP, 1.0);

        float rC = ssaoRadius / abs(sV.z - vP.z);
        
        occlusion += max(sign(oF.z - (sD + 0.001)), 0.0) * rC;
    }

    occlusion = 1.0 - (occlusion / kernelSize) * max(sign(normal.w - 0.5), 0.0);

    // Emission
    vec4 color = texture(colorSampler, vUV);
    vec4 emissive = texture(emissionSampler, vUV);

    for (int i = 0; i < directions; i++)
    {
        float d = (i / float(directions)) * pi2;
        vec2 dr = vec2(cos(d), sin(d)) * emissionRadius;
        for (int j = 0; j < quality; j++)
        {
            emissive += texture(emissionSampler, vUV + dr * (j / float(quality)));
        }
    }

    emissive /= quality * directions;

    float oB = occlusion * 0.5 + 0.5;

    vec3 fColor = color.xyz * oB + emissive.xyz * occlusion;

    // Tone map
    vec3 map = vec3(1.0f) - exp(-fColor.xyz * exposure);

    fragColor = vec4(map.xyz, 1.0);
    // fragColor = vec4(occlusion.xxx, 1.0);
}